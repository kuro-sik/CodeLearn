{"version":3,"sources":["../../../../src/components/Clickable/useState.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNames, noop } from '@vkontakte/vkjs';\nimport { mergeCalls } from '../../lib/mergeCalls';\nimport { useStateWithDelay } from './useStateWithDelay';\n\nexport interface StateProps {\n  /**\n   * Указывает, должен ли компонент реагировать на hover-состояние\n   */\n  hasHover?: boolean;\n  /**\n   * Позволяет управлять hovered-состоянием извне\n   */\n  hovered?: boolean;\n  /**\n   * Позволяет управлять activated-состоянием извне\n   */\n  activated?: boolean;\n  /**\n   * Указывает, должен ли компонент реагировать на active-состояние\n   */\n  hasActive?: boolean;\n\n  /**\n   * Позволяет родительскому компоненту\n   * иметь hovered-cостояние при наведении\n   * на любой дочерний элемент.\n   * По умолчанию состояние hovered у родителя сбрасывается.\n   *\n   * Присваивается родителькому компоненту.\n   *\n   * @example\n   * <Tappable hasHoverWithChildren>\n   *   <IconButton />\n   *   <IconButton />\n   *   <IconButton />\n   * </Tappable>\n   */\n  hasHoverWithChildren?: boolean;\n\n  /**\n   * Позволяет родительскому компоненту показывать hovered-состояние при наведении\n   * на текущий дочерний компонент.\n   *\n   * Присваивается дочернему компоненту.\n   *\n   * @example\n   * <Tappable>\n   *   <IconButton unlockParentHover />\n   *   <IconButton unlockParentHover />\n   *   <IconButton />\n   * </Tappable>\n   */\n  unlockParentHover?: boolean;\n\n  /**\n   * Длительность показа `activated`-состояния\n   */\n  activeEffectDelay?: number;\n\n  /**\n   * Стиль подсветки active-состояния\n   */\n  activeClassName?: string;\n\n  /**\n   * Стиль подсветки hover-состояния\n   */\n  hoverClassName?: string;\n}\n\nexport const DEFAULT_ACTIVE_EFFECT_DELAY = 600;\n\nconst ACTIVE_DELAY = 70;\n\ninterface UseHoverProps extends Pick<StateProps, 'hovered' | 'hasHover'> {\n  /**\n   * Блокирование активации состояний\n   */\n  lockState: boolean;\n  setParentStateLock: (v: boolean) => void;\n}\n\n/**\n * Управляет наведением на компонент, игнорирует тач события\n */\nfunction useHover({ hovered, hasHover = true, lockState, setParentStateLock }: UseHoverProps) {\n  const [hoveredStateLocal, setHoveredStateLocal] = React.useState(false);\n\n  const prevIsHoveredRef = React.useRef<boolean | undefined>(undefined);\n\n  const handleHover = React.useCallback(\n    (isHover: boolean) => {\n      setHoveredStateLocal(isHover);\n\n      const isHovered =\n        hovered ??\n        calculateStateValue({\n          hasState: hasHover,\n          isLocked: lockState,\n          stateValueLocal: isHover,\n        });\n\n      // проверка сделана чтобы реже вызывать обновление состояния\n      // контекста родителя\n      if (isHovered !== prevIsHoveredRef.current) {\n        prevIsHoveredRef.current = isHovered;\n        setParentStateLock(isHovered);\n      }\n    },\n    [setParentStateLock, hasHover, hovered, lockState],\n  );\n\n  const onPointerEnter: React.PointerEventHandler<any> = (e) => {\n    if (e.pointerType === 'touch') {\n      return;\n    }\n\n    handleHover(true);\n  };\n\n  const onPointerLeave = () => {\n    handleHover(false);\n  };\n\n  const isHovered =\n    hovered ??\n    calculateStateValue({\n      hasState: hasHover,\n      isLocked: lockState,\n      stateValueLocal: hoveredStateLocal,\n    });\n\n  return {\n    isHovered,\n    onPointerEnter: hasHover ? onPointerEnter : noop,\n    onPointerLeave: hasHover ? onPointerLeave : noop,\n  };\n}\n\ninterface UseActiveProps extends Pick<StateProps, 'activated' | 'activeEffectDelay' | 'hasActive'> {\n  /**\n   * Блокирование активации состояний\n   */\n  lockStateRef: React.MutableRefObject<boolean>;\n  setParentStateLock: (v: boolean) => void;\n}\n\n/**\n * Управляет активацией компонента\n */\nfunction useActive({\n  activated,\n  activeEffectDelay,\n  hasActive = true,\n  lockStateRef,\n  setParentStateLock,\n}: UseActiveProps) {\n  // передаём setParentStateLock, чтобы функция вызывалась вместе с установкой стейта,\n  // если установка отложена c помощью delay, то и вызов будет отложен\n  const [activatedState, setActivated] = useStateWithDelay<boolean>(false, 0, setParentStateLock);\n\n  // Список нажатий которые не требуется отменять\n  const pointersUp = React.useMemo(() => new Set<number>(), []);\n\n  const onPointerDown = () => {\n    if (lockStateRef.current) {\n      return;\n    }\n\n    setActivated(true, ACTIVE_DELAY);\n    // намеренно выставляем lock, так как setActivated вызов отложен\n    // а у отложенного setActivated setParentStateLock тоже вызовится отложенно\n    // родитель сейчас тоже обработает это же событие PointerDown\n    // если мы не залочим activatedState у родителя сейчас, то родитель выставит active состояние\n    setParentStateLock(true);\n  };\n\n  const onPointerCancel: React.PointerEventHandler = (e) => {\n    if (pointersUp.has(e.pointerId)) {\n      pointersUp.delete(e.pointerId);\n      return;\n    }\n\n    setActivated(false);\n  };\n\n  const onPointerUp: React.PointerEventHandler = (e) => {\n    pointersUp.add(e.pointerId);\n\n    if (lockStateRef.current) {\n      return;\n    }\n\n    setActivated(true);\n    setActivated(false, activeEffectDelay);\n  };\n\n  const isActivated =\n    activated ??\n    calculateStateValue({\n      hasState: hasActive,\n      isLocked: lockStateRef.current,\n      stateValueLocal: activatedState,\n    });\n\n  return {\n    isActivated,\n    onPointerLeave: hasActive ? onPointerCancel : noop,\n    onPointerDown: hasActive ? onPointerDown : noop,\n    onPointerCancel: hasActive ? onPointerCancel : noop,\n    onPointerUp: hasActive ? onPointerUp : noop,\n  };\n}\n\ninterface ClickableLockStateContextInterface {\n  lockHoverStateBubbling?: (v: boolean) => void;\n  lockActiveStateBubbling?: (v: boolean) => void;\n}\n\nexport const ClickableLockStateContext: React.Context<ClickableLockStateContextInterface> =\n  React.createContext<ClickableLockStateContextInterface>({\n    lockHoverStateBubbling: undefined,\n    lockActiveStateBubbling: undefined,\n  });\n\n/**\n * Блокирует стейт на всплытие\n */\nfunction useLockState(\n  setParentStateLockBubbling: (v: boolean) => void,\n): readonly [boolean, (v: boolean) => void, (...args: any[]) => void] {\n  const [lockState, setLockState] = React.useState(false);\n\n  const setStateLockBubblingImmediate = React.useCallback(\n    (isLock: boolean) => {\n      setLockState(isLock);\n      setParentStateLockBubbling(isLock);\n    },\n    [setParentStateLockBubbling],\n  );\n\n  return [lockState, setParentStateLockBubbling, setStateLockBubblingImmediate] as const;\n}\n\nfunction useLockRef(\n  setParentStateLockBubbling: (v: boolean) => void,\n): readonly [React.MutableRefObject<boolean>, (v: boolean) => void, (...args: any[]) => void] {\n  const lockStateRef = React.useRef(false);\n\n  const setStateLockBubblingImmediate = React.useCallback(\n    (isLock: boolean) => {\n      lockStateRef.current = isLock;\n      setParentStateLockBubbling(isLock);\n    },\n    [setParentStateLockBubbling],\n  );\n\n  return [lockStateRef, setParentStateLockBubbling, setStateLockBubblingImmediate] as const;\n}\n\n/**\n * Управляет состоянием компонента\n */\nexport function useState({\n  hovered,\n  hasHover,\n  activated,\n  hasActive,\n  activeEffectDelay,\n  unlockParentHover,\n  hoverClassName,\n  activeClassName,\n}: StateProps): {\n  stateClassName: string;\n  setLockHoverBubblingImmediate: (...args: any[]) => void;\n  setLockActiveBubblingImmediate: (...args: any[]) => void;\n} {\n  const { lockHoverStateBubbling = noop, lockActiveStateBubbling = noop } =\n    React.useContext(ClickableLockStateContext);\n\n  const [lockHoverState, setParentStateLockHoverBubbling, setLockHoverBubblingImmediate] =\n    useLockState(unlockParentHover ? noop : lockHoverStateBubbling);\n  const [lockActiveStateRef, setParentStateLockActiveBubbling, setLockActiveBubblingImmediate] =\n    useLockRef(lockActiveStateBubbling);\n\n  const { isHovered, ...hoverEvent } = useHover({\n    hasHover,\n    hovered,\n    lockState: lockHoverState,\n    setParentStateLock: setParentStateLockHoverBubbling,\n  });\n\n  const { isActivated, ...activeEvent } = useActive({\n    activated,\n    hasActive,\n    activeEffectDelay,\n    lockStateRef: lockActiveStateRef,\n    setParentStateLock: setParentStateLockActiveBubbling,\n  });\n\n  const stateClassName = classNames(isHovered && hoverClassName, isActivated && activeClassName);\n  const handlers = mergeCalls(hoverEvent, activeEvent);\n\n  return {\n    stateClassName,\n    setLockHoverBubblingImmediate,\n    setLockActiveBubblingImmediate,\n    ...handlers,\n  };\n}\n\n// Общая функция для определения конечного состояния active/hovered\nfunction calculateStateValue({\n  hasState,\n  isLocked,\n  stateValueLocal,\n}: {\n  hasState: boolean;\n  isLocked: boolean;\n  stateValueLocal: boolean;\n}): boolean {\n  return hasState && !isLocked && stateValueLocal;\n}\n"],"names":["ClickableLockStateContext","DEFAULT_ACTIVE_EFFECT_DELAY","useState","ACTIVE_DELAY","useHover","hovered","hasHover","lockState","setParentStateLock","hoveredStateLocal","setHoveredStateLocal","React","prevIsHoveredRef","useRef","undefined","handleHover","useCallback","isHover","isHovered","calculateStateValue","hasState","isLocked","stateValueLocal","current","onPointerEnter","e","pointerType","onPointerLeave","noop","useActive","activated","activeEffectDelay","hasActive","lockStateRef","activatedState","setActivated","useStateWithDelay","pointersUp","useMemo","Set","onPointerDown","onPointerCancel","has","pointerId","delete","onPointerUp","add","isActivated","createContext","lockHoverStateBubbling","lockActiveStateBubbling","useLockState","setParentStateLockBubbling","setLockState","setStateLockBubblingImmediate","isLock","useLockRef","unlockParentHover","hoverClassName","activeClassName","useContext","lockHoverState","setParentStateLockHoverBubbling","setLockHoverBubblingImmediate","lockActiveStateRef","setParentStateLockActiveBubbling","setLockActiveBubblingImmediate","hoverEvent","activeEvent","stateClassName","classNames","handlers","mergeCalls"],"mappings":"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"}